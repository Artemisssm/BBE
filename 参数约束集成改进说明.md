# 参数约束集成改进说明

## 改进内容

### 1. 后端改进

#### 1.1 支持模式类型筛选
- Mapper接口和XML添加 `modeType` 参数
- 查询约束时根据模式类型过滤
- 空值表示适用所有模式

#### 1.2 完善约束验证逻辑
新增支持的约束类型：
- **FIXED_VALUE**：固定值约束
- **FORMULA_CALCULATE**：公式计算约束
- **ENUM_LIMIT**：枚举限制约束
- **CONTROL_DISABLE**：控件禁用约束

#### 1.3 新增接口
```java
// 获取单元的所有约束（按参数分组）
GET /system/paramConstraint/unit/{unitName}/{unitType}/{modeType}
```

### 2. 前端改进

#### 2.1 加载约束规则
在参数配置页面加载时，获取该单元的所有约束规则：

```javascript
// 在 getParamList() 后调用
async function loadConstraints() {
  if (!unitInfo.value.unitName || !unitInfo.value.unitType) {
    return
  }
  
  try {
    const response = await getAllConstraintsForUnit(
      unitInfo.value.unitName,
      unitInfo.value.unitType,
      unitInfo.value.modeType || ''
    )
    constraintsMap.value = response.data || {}
    applyConstraints()
  } catch (error) {
    console.error('加载约束失败:', error)
  }
}
```

#### 2.2 应用约束规则
根据约束类型应用不同的规则：

```javascript
function applyConstraints() {
  paramList.value.forEach(param => {
    const constraints = constraintsMap.value[param.paramCode] || []
    
    // 重置约束状态
    param.disabled = false
    param.constraintHint = null
    param.limitedEnumOptions = null
    
    constraints.forEach(constraint => {
      // 检查约束条件是否满足
      if (!isConstraintConditionMet(constraint)) {
        return
      }
      
      switch (constraint.constraintType) {
        case 'CONTROL_DISABLE':
          param.disabled = true
          param.constraintHint = constraint.errorMessage || '该参数在当前条件下不可修改'
          break
          
        case 'ENUM_LIMIT':
          // 限制枚举选项
          if (constraint.constraintValue) {
            param.limitedEnumOptions = constraint.constraintValue.split(',')
            param.constraintHint = constraint.errorMessage || '部分选项已被限制'
          }
          break
          
        case 'VALUE_RANGE':
          // 显示范围提示
          param.constraintHint = constraint.errorMessage || 
            `取值范围: ${constraint.constraintValue}`
          break
          
        case 'FIXED_VALUE':
          // 显示固定值提示
          param.constraintHint = constraint.errorMessage || 
            `可选值: ${constraint.constraintValue}`
          break
          
        case 'FORMULA_CALCULATE':
          // 显示计算公式提示
          param.constraintHint = constraint.errorMessage || 
            `根据公式计算: ${constraint.constraintValue}`
          break
      }
    })
  })
  
  filteredParamList.value = paramList.value
}
```

#### 2.3 检查约束条件
```javascript
function isConstraintConditionMet(constraint) {
  const condition = constraint.constraintCondition
  if (!condition) {
    return true // 无条件，总是满足
  }
  
  const sourceParam = constraint.sourceParamName
  if (!sourceParam) {
    return false
  }
  
  const sourceValue = getParamValue(sourceParam)
  if (sourceValue === null || sourceValue === undefined) {
    return false
  }
  
  return evaluateCondition(String(sourceValue), condition)
}

function evaluateCondition(value, condition) {
  try {
    if (condition.startsWith('==')) {
      return value === condition.substring(2).trim()
    } else if (condition.startsWith('!=')) {
      return value !== condition.substring(2).trim()
    } else if (condition.startsWith('>=')) {
      return parseFloat(value) >= parseFloat(condition.substring(2))
    } else if (condition.startsWith('<=')) {
      return parseFloat(value) <= parseFloat(condition.substring(2))
    } else if (condition.startsWith('>')) {
      return parseFloat(value) > parseFloat(condition.substring(1))
    } else if (condition.startsWith('<')) {
      return parseFloat(value) < parseFloat(condition.substring(1))
    }
  } catch (e) {
    return false
  }
  return false
}
```

#### 2.4 参数变化时重新应用约束
```javascript
function handleParamChange(param) {
  // 清除之前的定时器
  if (autoSaveTimer) {
    clearTimeout(autoSaveTimer)
  }
  
  // 显示保存中状态
  autoSaveStatus.value = {
    type: 'saving',
    text: '验证中...'
  }
  
  // 重新应用约束（因为源参数可能影响其他参数）
  applyConstraints()
  
  // 防抖：500ms后验证并保存
  autoSaveTimer = setTimeout(() => {
    validateAndSaveParam(param)
  }, 500)
}
```

#### 2.5 枚举选项过滤
在枚举类型的参数中，根据约束限制可选项：

```vue
<el-select
  v-model="param.rawValue"
  placeholder="请选择"
  class="param-select"
  :disabled="param.disabled"
  @change="handleParamChange(param)"
>
  <el-option
    v-for="(label, value) in getFilteredEnumOptions(param)"
    :key="value"
    :label="label"
    :value="value"
    :disabled="isEnumOptionDisabled(param, value)"
  />
</el-select>
```

```javascript
function getFilteredEnumOptions(param) {
  const allOptions = getEnumOptions(param.enumOptions)
  
  // 如果有枚举限制约束
  if (param.limitedEnumOptions && param.limitedEnumOptions.length > 0) {
    const filtered = {}
    param.limitedEnumOptions.forEach(value => {
      if (allOptions[value]) {
        filtered[value] = allOptions[value]
      }
    })
    return filtered
  }
  
  return allOptions
}

function isEnumOptionDisabled(param, value) {
  // 如果有枚举限制约束，未在列表中的选项禁用
  if (param.limitedEnumOptions && param.limitedEnumOptions.length > 0) {
    return !param.limitedEnumOptions.includes(value)
  }
  return false
}
```

#### 2.6 验证时传递模式类型
```javascript
async function validateAndSaveParam(param) {
  try {
    // 构建所有参数的Map
    const allParamsMap = {}
    paramList.value.forEach(p => {
      allParamsMap[p.paramCode] = p.rawValue ? String(p.rawValue) : ''
    })
    
    // 验证约束
    const validateData = {
      unitName: unitInfo.value.unitName,
      unitType: unitInfo.value.unitType,
      modeType: unitInfo.value.modeType || '', // 添加模式类型
      paramName: param.paramCode,
      paramValue: param.rawValue ? String(param.rawValue) : '',
      allParams: allParamsMap
    }
    
    await validateParamConstraint(validateData)
    
    // 验证通过，保存参数
    autoSaveStatus.value = {
      type: 'saving',
      text: '保存中...'
    }
    
    await autoSaveParam(param)
    
  } catch (error) {
    // 验证失败，显示错误信息
    autoSaveStatus.value = {
      type: 'error',
      text: '验证失败'
    }
    
    const errorMsg = error.msg || error.message || '参数约束验证失败'
    proxy.$modal.msgError(errorMsg)
    
    // 5秒后隐藏错误状态
    setTimeout(() => {
      autoSaveStatus.value = null
    }, 5000)
  }
}
```

### 3. 使用流程

#### 3.1 配置约束
1. 进入"系统管理" → "参数约束"
2. 点击"新增"
3. 填写约束信息：
   - 源链路模式、源单元类型、源参数
   - 目标链路模式、目标单元类型、目标参数
   - **模式类型**：勾选适用的模式（不勾选表示所有模式）
   - 约束类型、约束条件、约束值
4. 保存

#### 3.2 查看约束效果
1. 进入基带单元列表
2. 点击某个单元的"参数配置"
3. 页面会自动加载该单元的约束规则
4. 约束效果：
   - **控件禁用**：满足条件时，参数控件置灰不可编辑
   - **枚举限制**：枚举参数的部分选项置灰或隐藏
   - **值范围**：显示约束提示，验证时检查范围
   - **固定值**：显示可选值提示，验证时检查
   - **公式计算**：显示计算公式提示，验证时检查

#### 3.3 约束提示
每个参数卡片底部会显示约束提示：
- 黄色背景的提示框
- 显示约束的错误提示信息
- 帮助用户了解参数的限制条件

### 4. 示例

#### 示例1：控件禁用约束
```
源参数：调制方式 == BPSK
目标参数：码率
约束类型：控件禁用
模式类型：（不勾选，适用所有模式）
错误提示：BPSK调制时码率固定，不可修改
```

效果：当调制方式选择BPSK时，码率参数控件自动置灰，显示提示信息。

#### 示例2：枚举限制约束（KSA模式特定）
```
源参数：频段 == K
目标参数：调制方式
约束类型：枚举限制
约束值：BPSK,QPSK,8PSK
模式类型：☑ KSA
错误提示：K频段仅支持BPSK、QPSK、8PSK调制
```

效果：在KSA模式下，当频段选择K时，调制方式下拉框中只显示BPSK、QPSK、8PSK三个选项。

#### 示例3：值范围约束（多模式）
```
源参数：调制方式 == QPSK
目标参数：码率
约束类型：值范围约束
约束值：0.5,0.8
模式类型：☑ KSA  ☑ KMA
错误提示：QPSK调制时码率范围应为0.5~0.8
```

效果：在KSA和KMA模式下，当调制方式选择QPSK时，码率参数显示范围提示，输入超出范围时验证失败。

### 5. 注意事项

1. **模式类型匹配**：约束查询时会根据单元的模式类型过滤，确保只应用适用的约束
2. **优先级**：多个约束同时生效时，按优先级排序，高优先级的约束先应用
3. **条件检查**：约束条件不满足时，约束不生效
4. **实时更新**：参数值变化时，会重新检查和应用约束
5. **性能优化**：约束规则在页面加载时一次性获取，避免频繁请求

### 6. 后续优化建议

1. **约束缓存**：将约束规则缓存到前端，减少重复请求
2. **批量验证**：支持一次验证多个参数，提高效率
3. **约束可视化**：在参数配置页面显示约束关系图
4. **约束模板**：提供常用约束模板，快速配置
5. **约束导入导出**：支持批量导入导出约束配置

## 部署步骤

1. 执行数据库脚本（如果还没执行）
2. 重新编译后端
3. 重启后端服务
4. 刷新前端页面

## 更新日期
2024-12-02
