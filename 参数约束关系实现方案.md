# 参数约束关系实现方案

## 概述

实现基带单元参数之间的约束关系，包括单元内部约束和跨单元约束，确保参数配置的合理性和一致性。

## 约束类型

### 1. 单元内部约束（SELF）

同一个单元内，参数之间的约束关系。

**示例**：
- 编码方式影响码率范围
- 调制方式影响符号率范围
- 帧长度影响交织深度

### 2. 跨单元约束（CROSS_UNIT）

同一块FPGA上，不同单元之间的约束关系。

**约束对**：
- **编码 ↔ 调制**：发送端链路
- **解调 ↔ 译码**：接收端链路

## 约束规则类型

### 1. VALUE_RANGE（值范围约束）

源参数的值影响目标参数的取值范围。

**示例**：编码方式影响码率范围
```json
{
  "type": "VALUE_RANGE",
  "rules": {
    "TURBO": {"minValue": 0.25, "maxValue": 0.9},
    "LDPC": {"minValue": 0.5, "maxValue": 0.95},
    "CONV": {"minValue": 0.33, "maxValue": 0.75}
  }
}
```

### 2. ENABLE_DISABLE（启用/禁用约束）

源参数的值决定目标参数是否可用。

**示例**：滤波器类型影响滚降系数
```json
{
  "type": "ENABLE_DISABLE",
  "rules": {
    "RRC": {"enabled": true, "range": {"minValue": 0.2, "maxValue": 0.5}},
    "GAUSS": {"enabled": false}
  }
}
```

### 3. VALUE_SYNC（值同步约束）

源参数变化时，目标参数自动同步。

**示例**：编码帧长度同步到调制
```json
{
  "type": "VALUE_SYNC",
  "formula": "target = source",
  "autoSync": true
}
```

### 4. VALUE_CALCULATE（值计算约束）

根据公式计算目标参数的值。

**示例**：编码码率影响调制符号率
```json
{
  "type": "VALUE_CALCULATE",
  "formula": "target = source * bitRate / modOrder",
  "description": "符号率 = 码率 × 比特率 / 调制阶数"
}
```

## 实际约束关系

### 编码单元（ENCODE）

#### 1. 编码方式 → 码率范围
- **TURBO编码**：支持码率 0.25 ~ 0.9
- **LDPC编码**：支持码率 0.5 ~ 0.95
- **卷积码**：支持码率 0.33 ~ 0.75

#### 2. 帧长度 → 交织深度
- 帧长度 ≤ 1024：交织深度最大 8
- 帧长度 > 1024：交织深度最大 16

#### 3. 编码方式 → 交织使能
- **TURBO/LDPC**：需要交织
- **卷积码**：可选交织

### 调制单元（MODULATE）

#### 1. 调制方式 → 符号率范围
- **BPSK**：1 ~ 100 Msps
- **QPSK**：2 ~ 200 Msps
- **8PSK**：3 ~ 300 Msps
- **16QAM**：4 ~ 400 Msps

#### 2. 滤波器类型 → 滚降系数
- **RRC滤波器**：需要设置滚降系数 0.2 ~ 0.5
- **高斯滤波器**：不需要滚降系数（禁用）

#### 3. 调制方式 → 功率回退
- **BPSK/QPSK**：功率回退 0 ~ 3 dB
- **8PSK/16QAM**：功率回退 3 ~ 6 dB

### 解调单元（DEMODULATE）

#### 1. 解调方式 → 载波同步
- **相干解调**：必须启用载波同步
- **非相干解调**：禁用载波同步

#### 2. 解调方式 → 软判决输出
- **相干解调**：支持软判决
- **非相干解调**：仅支持硬判决

#### 3. 符号率 → AGC带宽
- 符号率 < 10 Msps：AGC带宽 1 ~ 5 kHz
- 符号率 ≥ 10 Msps：AGC带宽 5 ~ 20 kHz

### 译码单元（DECODE）

#### 1. 译码算法 → 迭代次数
- **MAP算法**：4 ~ 8 次迭代
- **LOG-MAP算法**：6 ~ 12 次迭代
- **SOVA算法**：1 ~ 4 次迭代

#### 2. 软判决输入 → 量化位数
- **启用软判决**：量化位数 3 ~ 8 bit
- **禁用软判决**：量化位数固定 1 bit

#### 3. 译码算法 → 译码延迟
- **MAP/LOG-MAP**：延迟较大，需要缓冲
- **SOVA**：延迟较小

### 跨单元约束

#### 编码 → 调制（发送端）

1. **编码码率 → 调制符号率**
   - 公式：符号率 = 信息速率 / (码率 × 调制阶数)
   - 自动计算建议值

2. **编码帧长度 → 调制帧长度**
   - 自动同步，保持一致

3. **编码输出 → 调制输入**
   - 编码输出位宽 = 调制输入位宽

#### 解调 → 译码（接收端）

1. **解调方式 → 译码软判决**
   - 相干解调 → 启用软判决
   - 非相干解调 → 禁用软判决

2. **解调帧长度 → 译码帧长度**
   - 自动同步，保持一致

3. **解调输出位宽 → 译码输入位宽**
   - 必须匹配

## 数据库设计

### 约束规则表

```sql
CREATE TABLE sys_baseband_param_constraint (
    constraint_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    constraint_name VARCHAR(100) NOT NULL,
    constraint_type VARCHAR(20) NOT NULL,  -- SELF/CROSS_UNIT
    source_unit_type VARCHAR(16),
    source_param_code VARCHAR(64) NOT NULL,
    target_unit_type VARCHAR(16),
    target_param_code VARCHAR(64) NOT NULL,
    constraint_rule TEXT NOT NULL,  -- JSON格式
    enabled CHAR(1) DEFAULT '1',
    remark VARCHAR(500),
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

## 前端实现

### 1. 约束引擎

```javascript
// 约束引擎类
class ConstraintEngine {
  constructor(constraints, params) {
    this.constraints = constraints
    this.params = params
  }
  
  // 应用约束
  applyConstraint(sourceParam, sourceValue) {
    const relatedConstraints = this.findConstraints(sourceParam)
    
    relatedConstraints.forEach(constraint => {
      const targetParam = this.findParam(constraint.target_param_code)
      
      switch (constraint.constraint_rule.type) {
        case 'VALUE_RANGE':
          this.applyValueRange(targetParam, constraint, sourceValue)
          break
        case 'ENABLE_DISABLE':
          this.applyEnableDisable(targetParam, constraint, sourceValue)
          break
        case 'VALUE_SYNC':
          this.applyValueSync(targetParam, constraint, sourceValue)
          break
        case 'VALUE_CALCULATE':
          this.applyValueCalculate(targetParam, constraint, sourceValue)
          break
      }
    })
  }
  
  // 应用值范围约束
  applyValueRange(targetParam, constraint, sourceValue) {
    const rule = constraint.constraint_rule.rules[sourceValue]
    if (rule) {
      targetParam.minValue = rule.minValue
      targetParam.maxValue = rule.maxValue
      
      // 如果当前值超出范围，调整到边界
      if (targetParam.rawValue < rule.minValue) {
        targetParam.rawValue = rule.minValue
      } else if (targetParam.rawValue > rule.maxValue) {
        targetParam.rawValue = rule.maxValue
      }
    }
  }
  
  // 应用启用/禁用约束
  applyEnableDisable(targetParam, constraint, sourceValue) {
    const rule = constraint.constraint_rule.rules[sourceValue]
    if (rule) {
      targetParam.disabled = !rule.enabled
      
      if (rule.range) {
        targetParam.minValue = rule.range.minValue
        targetParam.maxValue = rule.range.maxValue
      }
      
      if (rule.value !== undefined) {
        targetParam.rawValue = rule.value
      }
    }
  }
  
  // 应用值同步约束
  applyValueSync(targetParam, constraint, sourceValue) {
    if (constraint.constraint_rule.autoSync) {
      targetParam.rawValue = sourceValue
    }
  }
  
  // 应用值计算约束
  applyValueCalculate(targetParam, constraint, sourceValue) {
    // 根据公式计算目标值
    const calculatedValue = this.evaluateFormula(
      constraint.constraint_rule.formula,
      sourceValue
    )
    targetParam.suggestedValue = calculatedValue
  }
}
```

### 2. 参数变化处理

```javascript
// 参数变化时应用约束
function handleParamChangeWithConstraint(param) {
  // 应用约束
  constraintEngine.applyConstraint(param.paramCode, param.rawValue)
  
  // 自动保存
  handleParamChange(param)
  
  // 如果是跨单元约束，需要通知其他单元
  if (hasC rossUnitConstraint(param)) {
    notifyRelatedUnits(param)
  }
}
```

### 3. 跨单元约束处理

```javascript
// 获取同一FPGA上的相关单元
function getRelatedUnits(currentUnit) {
  const channelNo = currentUnit.channelNo
  const boardNo = Math.floor((channelNo - 1) / 2) + 1
  const fpgaNo = (channelNo - 1) % 2
  
  // 查找同一FPGA上的其他单元
  const relatedUnits = unitList.filter(unit => {
    const unitBoardNo = Math.floor((unit.channelNo - 1) / 2) + 1
    const unitFpgaNo = (unit.channelNo - 1) % 2
    return unitBoardNo === boardNo && unitFpgaNo === fpgaNo && unit.unitId !== currentUnit.unitId
  })
  
  return relatedUnits
}

// 应用跨单元约束
function applyCrossUnitConstraint(sourceUnit, sourceParam, targetUnit) {
  // 查找跨单元约束规则
  const constraints = findCrossUnitConstraints(
    sourceUnit.unitType,
    sourceParam.paramCode,
    targetUnit.unitType
  )
  
  // 应用约束
  constraints.forEach(constraint => {
    const targetParam = findParamInUnit(targetUnit, constraint.target_param_code)
    constraintEngine.applyConstraint(sourceParam, targetParam, constraint)
  })
}
```

## 后端实现

### 1. 约束规则API

```java
/**
 * 获取参数约束规则
 */
@GetMapping("/constraints/{paramCode}")
public AjaxResult getConstraints(@PathVariable String paramCode) {
    List<ParamConstraint> constraints = constraintService.getConstraintsByParam(paramCode);
    return AjaxResult.success(constraints);
}

/**
 * 验证参数约束
 */
@PostMapping("/validate")
public AjaxResult validateConstraints(@RequestBody Map<String, Object> params) {
    ValidationResult result = constraintService.validateConstraints(params);
    return AjaxResult.success(result);
}
```

### 2. 约束验证服务

```java
@Service
public class ConstraintValidationService {
    
    /**
     * 验证参数约束
     */
    public ValidationResult validateConstraints(Long unitId, Map<String, Object> paramValues) {
        ValidationResult result = new ValidationResult();
        
        // 获取单元信息
        SysBasebandUnit unit = unitMapper.selectById(unitId);
        
        // 获取约束规则
        List<ParamConstraint> constraints = constraintMapper.selectByUnitType(unit.getUnitType());
        
        // 验证每个约束
        for (ParamConstraint constraint : constraints) {
            if (!validateConstraint(constraint, paramValues)) {
                result.addError(constraint.getConstraintName(), "约束验证失败");
            }
        }
        
        return result;
    }
    
    /**
     * 验证单个约束
     */
    private boolean validateConstraint(ParamConstraint constraint, Map<String, Object> paramValues) {
        Object sourceValue = paramValues.get(constraint.getSourceParamCode());
        Object targetValue = paramValues.get(constraint.getTargetParamCode());
        
        JSONObject rule = JSON.parseObject(constraint.getConstraintRule());
        String type = rule.getString("type");
        
        switch (type) {
            case "VALUE_RANGE":
                return validateValueRange(sourceValue, targetValue, rule);
            case "ENABLE_DISABLE":
                return validateEnableDisable(sourceValue, targetValue, rule);
            // ... 其他类型
        }
        
        return true;
    }
}
```

## 使用流程

### 1. 单元内部约束

```
用户操作：修改编码方式为 TURBO
↓
触发约束：编码方式 → 码率范围
↓
应用约束：码率范围调整为 0.25 ~ 0.9
↓
验证当前值：如果当前码率为 0.95，自动调整为 0.9
↓
自动保存：保存调整后的参数
↓
提示用户：显示"码率已自动调整为 0.9"
```

### 2. 跨单元约束

```
用户操作：修改编码帧长度为 2048
↓
触发约束：编码帧长度 → 调制帧长度
↓
查找相关单元：同一FPGA上的调制单元
↓
应用约束：调制帧长度自动同步为 2048
↓
自动保存：保存两个单元的参数
↓
提示用户：显示"调制帧长度已自动同步"
```

## 实现优先级

### 第一阶段：单元内部约束

1. 编码单元：编码方式 → 码率范围
2. 调制单元：调制方式 → 符号率范围
3. 调制单元：滤波器类型 → 滚降系数启用/禁用
4. 解调单元：解调方式 → 载波同步启用/禁用
5. 译码单元：译码算法 → 迭代次数范围

### 第二阶段：跨单元约束

1. 编码 → 调制：帧长度同步
2. 解调 → 译码：帧长度同步
3. 解调 → 译码：软判决启用/禁用

### 第三阶段：复杂约束

1. 编码 → 调制：码率影响符号率（计算约束）
2. 多参数联合约束
3. 条件约束（if-then-else）

## 注意事项

1. **循环约束检测**：避免A→B→A的循环约束
2. **约束冲突处理**：多个约束冲突时的优先级
3. **性能优化**：大量约束时的性能优化
4. **用户提示**：清晰提示哪些参数被自动调整
5. **约束禁用**：允许用户临时禁用某些约束
6. **约束日志**：记录约束触发和调整历史

## 扩展性

1. **自定义约束**：支持用户自定义约束规则
2. **约束模板**：预定义常用约束模板
3. **约束导入导出**：支持约束规则的导入导出
4. **约束可视化**：图形化显示参数约束关系
5. **约束测试**：提供约束规则测试工具

## 总结

通过实现参数约束关系：
1. **提升配置准确性**：自动应用约束，减少错误配置
2. **简化操作流程**：自动同步相关参数，减少手动操作
3. **符合实际需求**：约束规则符合通信系统实际
4. **灵活可扩展**：支持多种约束类型和自定义规则
5. **用户体验好**：自动调整并提示，操作流畅

这个方案提供了完整的约束关系框架，可以根据实际需求逐步实现。
