# 基带参数约束关系详细设计

## 设计原则

1. **符合实际**：约束关系基于通信系统实际工作原理
2. **分层设计**：单元名称 → 单元类型 → 参数
3. **优先级机制**：多个约束冲突时按优先级处理
4. **灵活配置**：支持启用/禁用约束规则

## 约束维度

### 三维约束模型

```
单元名称（8种）
    ↓
单元类型（4种：编码/调制/解调/译码）
    ↓
参数（多个）
    ↓
约束关系
```

## 8种单元名称的约束特点

### 1. 返向中低速数传

**特点**：中低速率，稳定可靠

**编码约束**：
- 优先卷积码和LDPC
- 码率：0.5 ~ 0.8
- 帧长度：512 ~ 2048

**调制约束**：
- 主要使用BPSK/QPSK
- 符号率：0.5 ~ 20 Msps
- 禁用高阶调制（8PSK/16QAM）

**跨单元约束**：
- 编码帧长度 → 调制帧长度（同步）
- 解调帧长度 → 译码帧长度（同步）

### 2. 返向高速数传

**特点**：高速率，大数据量，占用整板

**编码约束**：
- 优先LDPC
- 码率：0.75 ~ 0.95（高码率）
- 帧长度：2048 ~ 8192

**调制约束**：
- 支持高阶调制（QPSK/8PSK/16QAM）
- 符号率：10 ~ 200 Msps
- 功率回退：根据调制方式自动调整

**跨单元约束**：
- 编码码率 → 调制符号率（计算关系）
- 调制方式 → 功率回退（自动调整）

### 3. ACM数传

**特点**：自适应编码调制，根据信道质量动态调整

**编码约束**：
- 启用ACM时，码率自动调整（禁用手动设置）
- 支持多种编码方式切换
- 需要信道质量反馈

**调制约束**：
- 启用ACM时，调制方式自动调整（禁用手动设置）
- 支持BPSK/QPSK/8PSK/16QAM动态切换
- 符号率范围：1 ~ 100 Msps

**跨单元约束**：
- 编码ACM启用 ↔ 调制ACM启用（必须同步）
- 解调信噪比 → 编码码率（自适应调整）
- 解调信噪比 → 调制方式（自适应调整）

### 4. 前向数传小环

**特点**：环回测试，用于调试和验证

**编码约束**：
- 优先卷积码（简单可靠）
- 码率：0.5 ~ 0.75
- 禁用复杂编码（TURBO/LDPC）

**调制约束**：
- 仅支持BPSK/QPSK
- 低符号率：0.5 ~ 10 Msps
- 必须启用环回模式

**跨单元约束**：
- 调制环回 ↔ 解调环回（必须同步）
- 所有参数必须匹配（编码↔译码，调制↔解调）

### 5. 低速模拟源

**特点**：产生低速测试信号，不需要编码

**调制约束**：
- 支持BPSK/QPSK
- 符号率：0.1 ~ 10 Msps
- 数据源：固定码型或随机数据

**特殊约束**：
- 禁用编码单元（模拟源直接产生数据）
- 数据源类型 → 码型参数（固定码型时可配置）

### 6. 高速模拟源

**特点**：产生高速测试信号，不需要编码

**调制约束**：
- 支持QPSK/8PSK/16QAM
- 符号率：10 ~ 200 Msps
- 数据源：随机数据或PN序列

**特殊约束**：
- 禁用编码单元
- 高速率需要更大的缓冲深度

### 7. ACM模拟源

**特点**：模拟ACM自适应变化

**调制约束**：
- 启用ACM模拟
- 调制方式自动变化
- 符号率：1 ~ 100 Msps

**特殊约束**：
- ACM模拟启用 → 调制方式禁用手动设置
- ACM模拟启用 → 码率禁用手动设置
- 可配置ACM变化周期

### 8. 前向数传

**特点**：标准前向链路，全功能

**编码约束**：
- 支持所有编码方式
- 码率：0.5 ~ 0.9
- 帧长度：512 ~ 8192

**调制约束**：
- 支持所有调制方式
- 符号率：1 ~ 150 Msps
- 全功能配置

**跨单元约束**：
- 标准的编码→调制链路约束
- 标准的解调→译码链路约束

## 约束规则优先级

### 优先级说明

- **20+**：强制约束（必须满足）
- **10-19**：重要约束（建议满足）
- **1-9**：一般约束（可选）
- **0**：提示性约束（仅提示）

### 优先级示例

```
优先级 20：ACM编码调制联动（强制同步）
优先级 15：ACM启用时禁用手动设置（强制禁用）
优先级 10：编码方式影响码率范围（重要约束）
优先级 5：通用解调译码约束（一般约束）
```

## 约束匹配规则

### 1. 精确匹配

```sql
WHERE source_unit_name = '返向中低速数传' 
  AND source_unit_type = 'ENCODE'
  AND source_param_code = 'ENC_CODE_TYPE'
```

### 2. 单元类型匹配（通用规则）

```sql
WHERE source_unit_name IS NULL
  AND source_unit_type = 'DEMODULATE'
  AND source_param_code = 'DEMOD_TYPE'
```

### 3. 优先级排序

```sql
ORDER BY 
  CASE WHEN source_unit_name IS NOT NULL THEN 1 ELSE 0 END DESC,
  priority DESC
```

精确匹配优先于通用规则。

## 前端实现要点

### 1. 约束加载

```javascript
// 加载参数时同时加载约束规则
async function loadParamsWithConstraints(unitId) {
  const unit = await getBasebandUnit(unitId)
  const params = await listBasebandParamValue(unitId)
  const constraints = await getConstraintsByUnit(unit.unitName, unit.unitType)
  
  // 初始化约束引擎
  constraintEngine = new ConstraintEngine(constraints, params)
  
  // 应用初始约束
  constraintEngine.applyAllConstraints()
}
```

### 2. 参数变化处理

```javascript
function handleParamChange(param) {
  // 1. 应用约束
  const affectedParams = constraintEngine.applyConstraint(param)
  
  // 2. 显示变化提示
  if (affectedParams.length > 0) {
    showConstraintNotification(affectedParams)
  }
  
  // 3. 自动保存
  autoSaveParam(param)
  
  // 4. 如果影响其他单元，保存相关单元
  if (affectedParams.some(p => p.unitId !== param.unitId)) {
    autoSaveRelatedUnits(affectedParams)
  }
}
```

### 3. 跨单元约束

```javascript
// 获取同一FPGA上的相关单元
function getRelatedUnitsOnSameFPGA(currentUnit) {
  const channelNo = currentUnit.channelNo
  const boardNo = Math.floor((channelNo - 1) / 2) + 1
  const fpgaNo = (channelNo - 1) % 2
  
  return unitList.filter(unit => {
    const unitBoardNo = Math.floor((unit.channelNo - 1) / 2) + 1
    const unitFpgaNo = (unit.channelNo - 1) % 2
    
    // 同一FPGA
    if (unitBoardNo !== boardNo || unitFpgaNo !== fpgaNo) {
      return false
    }
    
    // 同一单元名称
    if (unit.unitName !== currentUnit.unitName) {
      return false
    }
    
    // 不同单元类型
    if (unit.unitId === currentUnit.unitId) {
      return false
    }
    
    // 检查是否有约束关系
    return hasConstraintRelation(currentUnit.unitType, unit.unitType)
  })
}

// 检查是否有约束关系
function hasConstraintRelation(type1, type2) {
  // 编码 ↔ 调制
  if ((type1 === 'ENCODE' && type2 === 'MODULATE') ||
      (type1 === 'MODULATE' && type2 === 'ENCODE')) {
    return true
  }
  
  // 解调 ↔ 译码
  if ((type1 === 'DEMODULATE' && type2 === 'DECODE') ||
      (type1 === 'DECODE' && type2 === 'DEMODULATE')) {
    return true
  }
  
  return false
}
```

## 用户界面提示

### 1. 约束生效提示

```javascript
// 参数被约束调整时的提示
{
  type: 'warning',
  title: '参数已自动调整',
  message: '由于编码方式改为TURBO，码率范围已调整为 0.25 ~ 0.9',
  duration: 5000
}
```

### 2. 跨单元影响提示

```javascript
// 影响其他单元时的提示
{
  type: 'info',
  title: '已同步相关单元',
  message: '编码帧长度已同步到调制单元（板1-FPGA0）',
  duration: 5000
}
```

### 3. 约束冲突提示

```javascript
// 约束冲突时的提示
{
  type: 'error',
  title: '约束冲突',
  message: '当前配置与其他参数约束冲突，请检查',
  duration: 0  // 不自动关闭
}
```

## 约束规则示例

### 示例1：返向中低速数传 - 编码方式影响码率

```json
{
  "unitName": "返向中低速数传",
  "unitType": "ENCODE",
  "sourceParam": "ENC_CODE_TYPE",
  "targetParam": "ENC_CODE_RATE",
  "constraint": {
    "type": "VALUE_RANGE",
    "rules": {
      "CONV": {
        "minValue": 0.5,
        "maxValue": 0.75,
        "recommended": 0.5,
        "message": "卷积码适合中低速，推荐码率0.5"
      },
      "LDPC": {
        "minValue": 0.5,
        "maxValue": 0.8,
        "recommended": 0.67,
        "message": "LDPC适合中低速，推荐码率0.67"
      }
    }
  }
}
```

### 示例2：ACM数传 - ACM启用影响参数

```json
{
  "unitName": "ACM数传",
  "unitType": "ENCODE",
  "sourceParam": "ENC_ACM_ENABLE",
  "targetParam": "ENC_CODE_RATE",
  "constraint": {
    "type": "ENABLE_DISABLE",
    "rules": {
      "1": {
        "enabled": false,
        "message": "ACM模式下码率由系统自动调整，无需手动设置"
      },
      "0": {
        "enabled": true
      }
    }
  }
}
```

### 示例3：前向小环 - 环回模式联动

```json
{
  "unitName": "前向数传小环",
  "sourceUnitType": "MODULATE",
  "sourceParam": "MOD_LOOPBACK_ENABLE",
  "targetUnitType": "DEMODULATE",
  "targetParam": "DEMOD_LOOPBACK_ENABLE",
  "constraint": {
    "type": "VALUE_SYNC",
    "formula": "target = source",
    "autoSync": true,
    "requiredValue": "1",
    "message": "小环模式必须同时启用调制和解调的环回"
  }
}
```

## 约束关系矩阵

### 单元内部约束矩阵

| 单元名称 | 编码约束数 | 调制约束数 | 解调约束数 | 译码约束数 |
|---------|-----------|-----------|-----------|-----------|
| 返向中低速数传 | 3 | 2 | 2 | 2 |
| 返向高速数传 | 3 | 3 | 2 | 2 |
| ACM数传 | 4 | 4 | 2 | 2 |
| 前向数传小环 | 2 | 2 | 3 | 2 |
| 低速模拟源 | 0 | 3 | 0 | 0 |
| 高速模拟源 | 0 | 3 | 0 | 0 |
| ACM模拟源 | 0 | 4 | 0 | 0 |
| 前向数传 | 3 | 3 | 2 | 2 |

### 跨单元约束矩阵

| 单元名称 | 编码→调制 | 解调→译码 | 特殊约束 |
|---------|----------|----------|---------|
| 返向中低速数传 | 帧同步 | 帧同步 | - |
| 返向高速数传 | 帧同步+码率计算 | 帧同步+软判决 | - |
| ACM数传 | ACM联动 | ACM联动 | 信道反馈 |
| 前向数传小环 | 帧同步 | 帧同步 | 环回联动 |
| 低速模拟源 | - | - | 禁用编码 |
| 高速模拟源 | - | - | 禁用编码 |
| ACM模拟源 | - | - | ACM模拟 |
| 前向数传 | 帧同步 | 帧同步 | - |

## 实现步骤

### 第一步：数据库准备

```bash
# 1. 创建约束表
mysql -u root -p ry-vue < RuoYi-Vue/sql/create_param_constraint_table.sql

# 2. 插入约束规则
mysql -u root -p ry-vue < RuoYi-Vue/sql/insert_param_constraints_by_unit_name.sql

# 3. 验证数据
mysql -u root -p ry-vue -e "SELECT COUNT(*) FROM sys_baseband_param_constraint;"
```

### 第二步：后端实现

1. 创建约束实体类：`SysBasebandParamConstraint.java`
2. 创建约束Mapper：`SysBasebandParamConstraintMapper.java`
3. 创建约束服务：`ConstraintValidationService.java`
4. 添加约束API：`SysBasebandParamConstraintController.java`

### 第三步：前端实现

1. 创建约束引擎：`src/utils/constraintEngine.js`
2. 修改参数配置页面：集成约束引擎
3. 添加约束提示组件：显示约束变化
4. 实现跨单元约束：处理同一FPGA上的单元

### 第四步：测试验证

1. 单元内部约束测试
2. 跨单元约束测试
3. 不同单元名称约束测试
4. 约束冲突处理测试

## 配置管理

### 约束规则管理界面

建议添加"约束规则管理"菜单：

**功能**：
- 查看所有约束规则
- 启用/禁用约束规则
- 修改约束规则
- 测试约束规则
- 导入/导出约束规则

**界面**：
```
[约束规则列表]
- 单元名称筛选
- 单元类型筛选
- 约束类型筛选
- 启用状态筛选

[约束规则详情]
- 源参数信息
- 目标参数信息
- 约束规则JSON
- 优先级设置
- 启用/禁用开关
```

## 性能优化

### 1. 约束缓存

```javascript
// 缓存约束规则，避免重复查询
const constraintCache = new Map()

function getConstraints(unitName, unitType) {
  const key = `${unitName}-${unitType}`
  if (!constraintCache.has(key)) {
    const constraints = await fetchConstraints(unitName, unitType)
    constraintCache.set(key, constraints)
  }
  return constraintCache.get(key)
}
```

### 2. 约束批量应用

```javascript
// 批量应用约束，减少重复计算
function applyConstraintsBatch(changedParams) {
  const affectedParams = new Set()
  
  changedParams.forEach(param => {
    const affected = constraintEngine.applyConstraint(param)
    affected.forEach(p => affectedParams.add(p))
  })
  
  return Array.from(affectedParams)
}
```

### 3. 延迟应用

```javascript
// 使用防抖，避免频繁应用约束
const debouncedApplyConstraint = debounce((param) => {
  constraintEngine.applyConstraint(param)
}, 300)
```

## 总结

通过增加单元名称维度的约束关系：

1. **更精确的约束**：不同单元名称有不同的约束规则
2. **符合实际应用**：约束规则基于实际通信系统
3. **灵活可配置**：支持精确匹配和通用规则
4. **优先级机制**：处理约束冲突
5. **跨单元支持**：同一FPGA上的单元联动

这个设计提供了完整的三维约束模型（单元名称 × 单元类型 × 参数），可以满足复杂的约束需求。
