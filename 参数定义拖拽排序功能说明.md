# 参数定义拖拽排序功能实现说明

## 功能概述

在基带参数定义界面实现了拖拽排序功能，用户可以通过拖拽调整参数的显示顺序，调整后的顺序会自动同步到数据库，并且序号会跟随改变。

**重要说明**：排序是按单元类型分组进行的，每个单元类型内的参数独立排序，序号从1开始。

## 实现内容

### 1. 前端实现（RuoYi-Vue3）

#### 1.1 界面调整
- **文件**: `RuoYi-Vue3/src/views/system/baseband/paramDef/index.vue`
- **修改内容**:
  - 使用 `sortablejs` 库实现拖拽功能
  - 在表格的"序号"列添加拖拽手柄（DCaret图标）
  - 序号显示为当前索引位置（`scope.$index + 1`），会随拖拽自动更新
  - 设置 `row-key="paramId"` 确保拖拽时正确识别行

#### 1.2 拖拽逻辑
```javascript
// 初始化拖拽排序
let sortableInstance = null  // 保存实例，避免重复创建

function initSortable() {
  // 销毁旧实例
  if (sortableInstance) {
    sortableInstance.destroy()
  }
  
  const tbody = tableRef.value.$el.querySelector('.el-table__body-wrapper tbody')
  sortableInstance = Sortable.create(tbody, {
    handle: '.sort-handle',  // 只能通过拖拽手柄进行拖拽
    animation: 150,          // 动画效果
    onEnd: ({ newIndex, oldIndex }) => {
      // 交换数组元素
      const movedItem = paramDefList.value.splice(oldIndex, 1)[0]
      paramDefList.value.splice(newIndex, 0, movedItem)
      // 更新排序到数据库
      updateSortOrder()
    }
  })
}
```

#### 1.3 排序更新（按单元类型分组）
```javascript
// 更新排序值并保存到数据库
async function updateSortOrder() {
  // 按单元类型分组
  const unitTypeGroups = {}
  paramDefList.value.forEach(item => {
    if (!unitTypeGroups[item.unitType]) {
      unitTypeGroups[item.unitType] = []
    }
    unitTypeGroups[item.unitType].push(item)
  })
  
  // 为每个单元类型内的参数分配排序值（从1开始）
  const updates = []
  Object.keys(unitTypeGroups).forEach(unitType => {
    unitTypeGroups[unitType].forEach((item, index) => {
      updates.push({
        paramId: item.paramId,
        sortOrder: index + 1  // 每个单元类型内从1开始
      })
      item.sortOrder = index + 1  // 更新本地数据
    })
  })
  
  await batchUpdateSortOrder(updates)
  proxy.$modal.msgSuccess('排序已更新')
}
```

#### 1.4 API接口
- **文件**: `RuoYi-Vue3/src/api/system/baseband/paramDef.js`
- **新增接口**:
```javascript
// 批量更新参数排序
export function batchUpdateSortOrder(data) {
  return request({
    url: '/system/baseband/param/sort',
    method: 'put',
    data: data
  })
}
```

### 2. 后端实现（RuoYi-Vue）

#### 2.1 Controller层
- **文件**: `RuoYi-Vue/ruoyi-admin/src/main/java/com/ruoyi/web/controller/system/SysBasebandParamDefController.java`
- **新增接口**:
```java
/**
 * 批量更新参数排序
 */
@PreAuthorize("@ss.hasPermi('system:basebandParam:edit')")
@Log(title = "基带参数定义", businessType = BusinessType.UPDATE)
@PutMapping("/sort")
public AjaxResult batchUpdateSortOrder(@RequestBody List<SysBasebandParamDef> paramList)
{
    return toAjax(sysBasebandParamDefService.batchUpdateSortOrder(paramList));
}
```

#### 2.2 Service层
- **接口文件**: `RuoYi-Vue/ruoyi-system/src/main/java/com/ruoyi/system/service/ISysBasebandParamDefService.java`
- **实现文件**: `RuoYi-Vue/ruoyi-system/src/main/java/com/ruoyi/system/service/impl/SysBasebandParamDefServiceImpl.java`
- **新增方法**:
```java
/**
 * 批量更新参数排序
 */
@Override
public int batchUpdateSortOrder(List<SysBasebandParamDef> paramList)
{
    int result = 0;
    for (SysBasebandParamDef param : paramList) {
        result += sysBasebandParamDefMapper.updateSortOrder(param.getParamId(), param.getSortOrder());
    }
    return result;
}
```

#### 2.3 Mapper层
- **接口文件**: `RuoYi-Vue/ruoyi-system/src/main/java/com/ruoyi/system/mapper/SysBasebandParamDefMapper.java`
- **新增方法**:
```java
/**
 * 更新参数排序
 * 注意：使用@Param注解指定参数名称，避免MyBatis参数绑定错误
 */
public int updateSortOrder(@Param("paramId") Long paramId, @Param("sortOrder") Integer sortOrder);
```

- **XML文件**: `RuoYi-Vue/ruoyi-system/src/main/resources/mapper/system/SysBasebandParamDefMapper.xml`
- **新增SQL**:
```xml
<update id="updateSortOrder" parameterType="map">
    update sys_baseband_param_def
    set sort_order = #{sortOrder}
    where param_id = #{paramId}
</update>
```

#### 2.4 查询排序优化
- **修改**: 查询列表时先按单元类型分组，再按 `sort_order` 字段排序
```xml
<select id="selectSysBasebandParamDefList">
    ...
    order by unit_type, COALESCE(sort_order, 999999), param_id
</select>
```
- **说明**: 
  - 先按 `unit_type` 分组，确保不同单元类型的参数分开显示
  - 在每个单元类型内，按 `sort_order` 排序
  - 使用 `COALESCE(sort_order, 999999)` 确保没有设置排序的参数排在最后
  - 相同排序值时按 `param_id` 排序保证稳定性

## 使用说明

### 1. 拖拽排序
1. 在参数定义列表中，将鼠标悬停在"序号"列的拖拽图标上
2. 按住鼠标左键拖动参数行到目标位置
3. 松开鼠标，系统自动保存新的排序
4. 序号会自动更新为新的位置编号

### 2. 序号说明
- 序号从1开始递增
- 拖拽后序号自动重新计算
- 序号反映参数在当前页的显示位置
- **重要**：每个单元类型内的参数独立排序，序号都从1开始

### 3. 排序持久化
- 拖拽完成后立即保存到数据库
- 刷新页面后排序保持不变
- 按照 `unit_type` 和 `sort_order` 字段排序显示
- 每个单元类型内的参数独立排序

## 技术要点

### 1. 前端技术
- **sortablejs**: 实现拖拽功能的核心库
- **Element Plus Table**: 表格组件，支持行拖拽
- **Vue3 Composition API**: 使用响应式数据和生命周期

### 2. 后端技术
- **批量更新**: 循环更新每个参数的排序值
- **事务处理**: 确保批量更新的原子性
- **权限控制**: 使用 `@PreAuthorize` 注解控制访问权限

### 3. 数据库设计
- **sort_order字段**: INT类型，存储排序值
- **默认值**: NULL（未设置排序的参数）
- **排序规则**: 升序排列，NULL值排在最后

## 注意事项

1. **权限要求**: 需要 `system:basebandParam:edit` 权限才能拖拽排序
2. **并发控制**: 多用户同时拖拽可能导致排序冲突，建议避免同时操作
3. **性能考虑**: 批量更新采用循环方式，参数数量较多时可能影响性能
4. **错误处理**: 拖拽失败时会提示错误信息，并重新加载列表恢复原状态
5. **MyBatis参数绑定**: Mapper接口方法有多个参数时，必须使用 `@Param` 注解指定参数名称
6. **单元类型分组**: 排序是按单元类型分组的，每个单元类型内独立排序
7. **Sortable实例管理**: 避免重复创建实例，每次初始化前先销毁旧实例

## 后续优化建议

1. **批量更新优化**: 使用批量SQL语句替代循环更新，提升性能
2. **乐观锁**: 添加版本号字段，防止并发更新冲突
3. **拖拽范围限制**: 限制只能在同一单元类型内拖拽（当前已按单元类型分组排序）
4. **撤销功能**: 添加撤销按钮，允许恢复上一次的排序
5. **排序初始化**: 为现有数据自动生成初始排序值
6. **跨页拖拽**: 支持跨分页拖拽排序

## 测试建议

1. **功能测试**:
   - 拖拽单个参数到不同位置
   - 连续拖拽多个参数
   - 刷新页面验证排序是否保持

2. **边界测试**:
   - 拖拽第一个参数到最后
   - 拖拽最后一个参数到第一个
   - 拖拽到相邻位置

3. **异常测试**:
   - 网络异常时拖拽
   - 无权限用户尝试拖拽
   - 数据库连接失败时拖拽

## 部署说明

1. **前端部署**:
   ```bash
   cd RuoYi-Vue3
   npm install
   npm run build
   ```

2. **后端部署**:
   ```bash
   cd RuoYi-Vue
   mvn clean package
   ```

3. **数据库检查**:
   - 确认 `sys_baseband_param_def` 表存在 `sort_order` 字段
   - 字段类型: INT
   - 允许NULL值

## 跨页面自动刷新

### 实现方案
使用 Pinia Store 实现跨组件通信，当参数定义排序更新后，自动通知参数配置页面刷新。

### 实现步骤

#### 1. 创建 Baseband Store
**文件**: `RuoYi-Vue3/src/store/modules/baseband.js`

```javascript
import { defineStore } from 'pinia'

export const useBasebandStore = defineStore('baseband', {
  state: () => ({
    paramDefUpdateTime: 0,        // 参数定义更新时间戳
    paramDefUpdateUnitType: null  // 更新的单元类型
  }),
  
  actions: {
    // 通知参数定义已更新
    notifyParamDefUpdated(unitType = null) {
      this.paramDefUpdateTime = Date.now()
      this.paramDefUpdateUnitType = unitType
    }
  }
})
```

#### 2. 参数定义页面发送通知
在排序更新成功后，调用 Store 的 action：

```javascript
// 批量更新排序成功后
await batchUpdateSortOrder(updates)
proxy.$modal.msgSuccess('排序已更新')

// 通知其他页面参数定义已更新
updatedUnitTypes.forEach(unitType => {
  basebandStore.notifyParamDefUpdated(unitType)
})
```

#### 3. 参数配置页面监听更新
使用 `watch` 监听 Store 的变化：

```javascript
// 监听参数定义更新，自动刷新参数列表
watch(() => basebandStore.paramDefUpdateTime, (newTime, oldTime) => {
  if (newTime > 0 && newTime !== oldTime) {
    const updatedUnitType = basebandStore.paramDefUpdateUnitType
    const currentUnitType = unitInfo.value.unitType
    
    // 只刷新相关单元类型的参数
    if (!updatedUnitType || updatedUnitType === currentUnitType) {
      setTimeout(() => {
        getParamList()
        proxy.$modal.msgSuccess('参数列表已更新')
      }, 300)
    }
  }
})
```

### 使用效果
1. 在参数定义页面拖拽调整参数顺序
2. 保存成功后，自动通知所有打开的参数配置页面
3. 参数配置页面自动刷新，显示最新的参数顺序
4. 无需手动刷新或重新打开页面

## 更新日期

2025-12-03
